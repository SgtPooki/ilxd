syntax = "proto3";
option go_package="github.com/project-illium/ilxd/rpc/pb";

package pb;

import "transactions.proto";
import "blocks.proto";

service BlockchainService {
    // GetMempoolInfo returns the state of the current mempool
    rpc GetMempoolInfo(GetMempoolInfoRequest) returns (GetMempoolInfoResponse) {}

    // GetMempool returns all the transactions in the mempool
    rpc GetMempool(GetMempoolRequest) returns (GetMempoolResponse) {}

    // GetBlockchainInfo returns data about the blockchain including the most recent
    // block hash and height.
    rpc GetBlockchainInfo(GetBlockchainInfoRequest) returns (GetBlockchainInfoResponse) {}

    // GetBlockInfo returns a BlockHeader plus some extra metadata.
    rpc GetBlockInfo(GetBlockInfoRequest)returns (GetBlockInfoResponse) {}

    // GetBlock returns the detailed data for a block.
    rpc GetBlock(GetBlockRequest) returns (GetBlockResponse) {}

    // GetCompressedBlock returns a block that is stripped down to just the outputs.
    // It is the bare minimum information a client side wallet needs to compute its internal
    // state.
    rpc GetCompressedBlock(GetCompressedBlockRequest) returns (GetCompressedBlockResponse) {}

    // GetHeaders returns a batch of headers according to the request parameters.
    rpc GetHeaders(GetHeadersRequest) returns (GetHeadersResponse) {}

    // GetCompressedBlocks returns a batch of CompressedBlocks according to the request parameters.
    rpc GetCompressedBlocks(GetCompressedBlocksRequest) returns (GetCompressedBlocksResponse) {}

    // GetTransaction returns the transaction for the given transaction ID.
    //
    // **Requires TxIndex**
    rpc GetTransaction(GetTransactionRequest) returns (GetTransactionResponse) {}

    // GetMerkleProof returns a Merkle (SPV) proof for a specific transaction
    // in the provided block.
    //
    // **Requires TxIndex**
    rpc GetMerkleProof(GetMerkleProofRequest) returns (GetMerkleProofResponse) {}

    // GetValidator returns all the information about the given validator including number
    // of staked coins.
    rpc GetValidator(GetValidatorRequest) returns (GetValidatorResponse) {}

    // GetValidatorSetInfo returns information about the validator set.
    rpc GetValidatorSetInfo(GetValidatorSetInfoRequest) returns (GetValidatorSetInfoResponse) {}

    // GetValidatorSet returns all the validators in the current validator set.
    rpc GetValidatorSet(GetValidatorSetRequest) returns (GetValidatorSetResponse) {}

    // GetAccumulatorCheckpoint returns the accumulator at the requested height.
    // If there is no checkpoint at that height, the *next* checkpoint found in the
    // chain will be returned.
    rpc GetAccumulatorCheckpoint(GetAccumulatorCheckpointRequest) returns (GetAccumulatorCheckpointResponse) {}

    // SubmitTransaction validates a transaction and submits it to the network. An error will be returned
    // if it fails validation.
    rpc SubmitTransaction(SubmitTransactionRequest) returns (SubmitTransactionResponse) {}

    // SubscribeBlocks returns a stream of notifications when new blocks are finalized and
    // connected to the chain.
    rpc SubscribeBlocks(SubscribeBlocksRequest) returns (stream BlockNotification) {}
}

service WalletServerService {
    // RegisterViewKey registers a new view key with the server. The server will use this key when
    // attempting to decrypt each output. If outputs decrypt, they will be indexed so the client
    // can fetch them later.
    //
    // To free up resources keys will automatically unregister after some time if the wallet has not
    // connected in some time.
    rpc RegisterViewKey(RegisterViewKeyRequest) returns (RecomputeChainStateResponse) {}

    // SubscribeTransactions subscribes to a stream of TransactionsNotifications that match to the
    // provided view key.
    rpc SubscribeTransactions(SubscribeTransactionsRequest) returns (stream TransactionNotification) {}

    // GetWalletTransactions returns a list of transactions for the provided view key.
    rpc GetWalletTransactions(GetWalletTransactionsRequest) returns (GetWalletTransactionsResponse) {}

    // GetTxoProof returns the merkle inclusion proof for the given commitment. This information is needed
    // by the client to create the zero knowledge proof needed to spend the transaction.
    rpc GetTxoProof(GetTxoProofRequest) returns (GetTxoProofResponse) {}
}

service WalletService {
    rpc GetBalance(GetBalanceRequest) returns (GetBalanceResponse) {}
    rpc GetWalletSeed(GetWalletSeedRequest) returns (GetWalletSeedResponse) {}
    rpc GetAddresses(GetAddressesRequest) returns (GetAddressesResponse) {}
    rpc GetNewAddress(GetNewAddressRequest) returns (GetNewAddressResponse) {}
    rpc GetTransactions(GetTransactionsRequest) returns (GetTransactionsResponse) {}
    rpc GetUtxos(GetUtxosRequest) returns (GetUtxosResponse) {}
    rpc GetPrivateKey(GetPrivateKeyRequest) returns (GetPrivateKeyResponse) {}
    rpc ImportAddress(ImportAddressRequest) returns (ImportAddressResponse) {}
    rpc CreateMultisigAddress(CreateMultisigAddressRequest) returns (CreateMultisigAddressResponse) {}
    rpc ProveMultisig(ProveMultisigRequest) returns (ProveMultisigResponse) {}
    rpc WalletLock(WalletLockRequest) returns (WalletUnlockRequest) {}
    rpc WalletUnlock(WalletUnlockRequest) returns (WalletUnlockResponse) {}
    rpc ChangeWalletPassphrase(ChangeWalletPassphraseRequest) returns (ChangeWalletPassphraseResponse) {}
    rpc DeletePrivateKeys(DeletePrivateKeysRequest) returns (DeletePrivateKeysResponse) {}
    rpc CreateRawTransaction(CreateRawTransactionRequest) returns (CreateRawTransactionResponse) {}
    rpc ProveRawTransaction(ProveRawTransactionRequest) returns (ProveRawTransactionRequest) {}
    rpc BroadcastRawTransaction(BroadcastRawTransactionRequest) returns (BroadcastRawTransactionResponse) {}
    rpc Stake(StakeRequest) returns (StakeResponse) {}
    rpc SetAutoStakeRewards(SetAutoStakeRewardsRequest) returns (SetAutoStakeRewardsResponse) {}
    rpc Spend(SpendRequest) returns (SpendResponse) {}
}

service NodeService {
    rpc GetHostInfo(GetHostInfoRequest) returns (GetHostInfoResponse) {}
    rpc GetPeers(GetPeersRequest) returns (GetPeersResponse) {}
    rpc AddPeer(AddPeerRequest) returns (AddPeerResponse) {}
    rpc BlockPeer(BlockPeerRequest) returns (BlockPeerResponse) {}
    rpc SetLogLevel(SetLogLevelRequest) returns (SetLogLevelResponse) {}
    rpc GetMinFeePerByte(GetMinFeePerByteRequest) returns (GetMinFeePerByteResponse) {}
    rpc SetMinFeePerByte(SetMinFeePerByteRequest) returns (SetMinFeePerByteResponse) {}
    rpc GetMinStake(GetMinStakeRequest) returns (GetMinStakeResponse) {}
    rpc SetMinStake(SetMinStakeRequest) returns (SetMinStakeResponse) {}
    rpc GetBlockSizeSoftLimit(GetBlockSizeSoftLimitRequest) returns (GetBlockSizeSoftLimitResponse) {}
    rpc SetBlockSizeSoftLimit(SetBlockSizeSoftLimitRequest) returns (SetBlockSizeSoftLimitResponse) {}
    rpc GetTreasuryWhitelist(GetTreasuryWhitelistRequest) returns (GetTreasuryWhitelistResponse) {}
    rpc WhitelistTreasuryTransaction(WhitelistTreasuryTransactionRequest) returns (WhitelistTreasuryTransactionResponse) {}
    rpc ReconsiderBlock(ReconsiderBlockRequest) returns (ReconsiderBlockResponse) {}
    rpc RecomputeChainState(RecomputeChainStateRequest) returns (RecomputeChainStateResponse) {}
}

// RPC MESSAGES

// BlockchainService
message GetMempoolInfoRequest{}
message GetMempoolInfoResponse {
    // The count of transactions in the mempool
    uint32 size  = 1;
    // The size in bytes of all transactions in the mempool
    uint32 bytes = 2;
}

message GetMempoolRequest {
    // When `full_transactions` is true, full transaction data is provided
    // instead of just transaction hashes. Default is false.
    bool full_transactions = 1;
}
message GetMempoolResponse {
    // List of unconfirmed transactions.
    repeated TransactionData transaction_data = 1;
}

message GetBlockchainInfoRequest {}
message GetBlockchainInfoResponse {
    // Illium network types
    enum Network {
        // Live public network with monetary value
        MAINNET  = 0;
        // An isolated environment for automated testing
        REGTEST  = 1;
        // A public environment where monetary value is agreed to be zero,
        // and some checks for transaction conformity are disabled.
        TESTNET  = 2;
    }

    // Which network the node is operating on
    Network network          = 1;
    // The current number of blocks in the chain
    int32 best_height        = 2;
    // The hash of the best (tip) block in the chain
    bytes best_block_ID      = 3;
    // The timestamp of the best block
    int64 block_time         = 4;
    // When `tx_index` is true, the node has full transaction index enabled
    bool tx_index            = 5;
    // The total number of coins in circulation
    uint64 ciculating_supply = 6;
    // The total number of coins staked
    uint64 total_staked      = 7;
}

message GetBlockInfoRequest {
    oneof id_or_height {
        // The block hash as a byte array or hex encoded string
        bytes block_ID = 1;
        // The block number
        int32 height   = 2;
    }
}
message GetBlockInfoResponse {
    // Marshaled block header data, as well as metadata
    BlockInfo info = 1;
}

message GetBlockRequest {
    oneof id_or_height {
        // The block hash as a byte array or hex encoded string
        bytes block_ID = 1;
        // The block number
        int32 height   = 2;
    }
}
message GetBlockResponse {
    // The full block response
    Block block = 1;
}

message GetCompressedBlockRequest {
    oneof id_or_height {
        // The block hash as a byte array or hex encoded string
        bytes block_ID = 1;
        // The block number
        int32 height   = 2;
    }
}
message GetCompressedBlockResponse {
    // The compressed block contains only transaction outputs
    CompressedBlock block = 1;
}

message GetHeadersRequest {
    // The height to start receiving headers
    uint32 start_height = 1;
    // The last header height to return. Note that a maximum of 2000
    // blocks will be returned per request. If end_height is > start_height + 1999
    // then end_height will be set set to start_height + 1999 and 2000 headers
    // will be returned. If end_height is past the tip of the chain the headers
    // will be returned up to the tip.
    //
    // If end_height is less than start_height 2000 headers will be returned.
    uint32 end_height   = 2;
}
message GetHeadersResponse {
    repeated BlockHeader headers = 1;
}

message GetCompressedBlocksRequest {
    // The height to start receiving headers
    uint32 start_height = 1;
    // The last block height to return. Note that a maximum of 2000 blocks will be returned
    // per request. If end_height is > start_height + 1999 then end_height will be set set
    // to start_height + 1999 and 2000 compressed blocks will be returned. If end_height is
    // past the tip of the chain the compressed blocks will be returned up to the tip.
    //
    // If end_height is less than start_height 2000 blocks will be returned.
    uint32 end_height   = 2;
}
message GetCompressedBlocksResponse {
    // The compressed block response
    repeated CompressedBlock blocks = 1;
}

message GetTransactionRequest {
    // A transaction hash
    bytes transaction_ID = 1;
}
message GetTransactionResponse {
    // The transaction response
    Transaction tx = 1;
}

message GetMerkleProofRequest {
    // A transaction hash
    bytes transaction_ID = 1;
}
message GetMerkleProofResponse {
    // Block header information for the corresponding transaction
    BlockInfo block       = 1;
    // A list containing the transaction hash, the adjacent leaf transaction hash
    // and the hashes of the highest nodes in the merkle tree not built with the transaction.
    // Proof hashes are ordered following transaction order, or left to right on the merkle tree
    repeated bytes hashes = 2;
    // Binary representing the location of the matching transaction in the full merkle tree,
    // starting with the root (`1`) at position/level 0, where `1` corresponds
    // to a left branch and `01` is a right branch.
    bytes flags = 3;
}

message GetValidatorRequest {
    // A serialized validator ID
    bytes validator_ID = 1;
}
message GetValidatorResponse {
    // The validator response
    Validator validator = 1;
}

message GetValidatorSetInfoRequest{}
message GetValidatorSetInfoResponse{
    // The total number of coins staked on the network
    uint64 total_staked   = 1;
    // The total number of validators on the network
    uint32 num_validators = 2;
}

message GetValidatorSetRequest{}
message GetValidatorSetResponse{
    // The full list of validators on the network
    repeated Validator validators = 1;
}

message GetAccumulatorCheckpointRequest{
    // The height of the accumulator checkpoint to return.
    // If there is no checkpoint at that height, the *next*
    // checkpoint found in the chain will be returned.
    //
    // An error will be returned if there is no checkpoint after
    // the provided height.
    uint32 height = 1;
}
message GetAccumulatorCheckpointResponse{
    // The height of the checkpoint
    uint32 height              = 1;
    // The number of entries in the accumulator at this checkpoint
    uint64 num_entries         = 2;
    // The accumulator hashes
    repeated bytes accumulator = 3;
}

message SubmitTransactionRequest {
    // The transaction to submit to the network
    Transaction transaction = 1;
}
message SubmitTransactionResponse {
    // The transaction ID of the transaction.
    //
    // If submission was unsuccessful and error will be returned.
    bytes transaction_ID = 1;
}

message SubscribeBlocksRequest {
    // When full_block is true, a complete marshaled block is sent.
    // Default is false, block metadata is sent. See `BlockInfo`.
    bool full_block        = 1;

    // When full_transactions is true, provide full transaction info
    // for a marshaled block.
    //
    // Default is false, only the transaction IDs are included for
    // a marshaled block.
    bool full_transactions = 2;
}

// WalletServerService
message RegisterViewKeyRequest {
    // A view key to register with the server.
    string view_key = 1;

    // The date the address was created. The server will scan historical blocks
    // for matching transactions from the birthday forward. Please don't use an
    // earlier birthday than needed as it puts more stress on the server.
    int64 birthday = 2;
}
message RegisterViewKeyResponse {}

message SubscribeTransactionsRequest {
    // A list of view keys to subscribe to
    repeated string view_keys   = 1;

    // When include_mempool is true, new unconfirmed transactions from mempool are
    // included apart from the ones finalized in a block.
    bool include_mempool        = 2;

    // When include_in_block is true, transactions are included when they are finalized.
    // This notification is sent in addition to any requested mempool notifications.
    bool include_in_block       = 3;
}

message GetWalletTransactionsRequest{
    // The view key to query transactions
    string view_key = 1;

    // The number of transactions to skip, starting with the oldest first.
    // Does not affect results of unconfirmed transactions.
    uint32 nb_skip = 2;
    // Specify the number of transactions to fetch.
    uint32 nb_fetch = 3;


    oneof start_block {
        // Recommended. Only get transactions after (or within) a
        // starting block identified by hash.
        bytes block_ID = 4;
        // Recommended. Only get transactions after (or within) a
        // starting block identified by block number.
        int32 height = 5;
    }
}
message GetWalletTransactionsResponse {
    // A list of transactions as the response
    repeated Transaction transactions = 1;
}

message GetTxoProofRequest {
    // The output commitment to fetch the txo proof for
    bytes commitment = 1;
}
message GetTxoProofResponse {
    // The commitment this inclusion proof is for
    bytes commitment           = 1;
    // The hashes that form the root preimage
    repeated bytes accumulator = 2;
    // The merkle hashes linking the commitment to the accumulator
    repeated bytes hashes      = 3;
    // Flags indicate whether a hash in the hash list is left or right.
    // 0 == left, 1 == right.
    uint64 flags               = 4;
    // The index of this commitment in the tree
    uint64 index               = 5;
}

// WalletService
message GetBalanceRequest {}
message GetBalanceResponse {
    // Balance response
    uint64 balance = 1;
}

message GetWalletSeedRequest {}
message GetWalletSeedResponse {
    // The wallet's mnemonic seed
    string mnemonic_seed = 1;
}
message GetAddressesRequest {}
message GetAddressesResponse {
    // The most recent address generated by the wallet
    string address = 1;
}
message GetNewAddressRequest {}
message GetNewAddressResponse {
    // A fresh address generated by the wallet
    string address = 1;
}
message GetTransactionsRequest {
    // Transaction ID as a byte array or hex encoded string
    bytes transaction_ID = 1;
}
message GetTransactionsResponse {
    // Returned transaction
    Transaction tx = 1;
}
message GetUtxosRequest {}
message GetUtxosResponse {}
message GetPrivateKeyRequest {}
message GetPrivateKeyResponse {}
message ImportAddressRequest {}
message ImportAddressResponse {}
message CreateMultisigAddressRequest {}
message CreateMultisigAddressResponse {}
message ProveMultisigRequest {}
message ProveMultisigResponse {}
message WalletLockRequest {}
message WalletUnlockRequest {}
message WalletUnlockResponse {}
message ChangeWalletPassphraseRequest {}
message ChangeWalletPassphraseResponse {}
message DeletePrivateKeysRequest {}
message DeletePrivateKeysResponse {}
message CreateRawTransactionRequest {}
message CreateRawTransactionResponse {}
message ProveRawTransactionRequest {}
message ProveRawTransactionResponse {}
message BroadcastRawTransactionRequest {}
message BroadcastRawTransactionResponse {}
message StakeRequest {}
message StakeResponse {}
message SetAutoStakeRewardsRequest {}
message SetAutoStakeRewardsResponse {}
message SpendRequest {}
message SpendResponse {}

// NodeService
message GetHostInfoRequest {}
message GetHostInfoResponse {}
message GetPeersRequest {}
message GetPeersResponse {}
message AddPeerRequest {}
message AddPeerResponse {}
message BlockPeerRequest {}
message BlockPeerResponse {}
message SetLogLevelRequest {}
message SetLogLevelResponse {}
message GetMinFeePerByteRequest {}
message GetMinFeePerByteResponse {}
message SetMinFeePerByteRequest {}
message SetMinFeePerByteResponse {}
message GetMinStakeRequest {}
message GetMinStakeResponse {}
message SetMinStakeRequest {}
message SetMinStakeResponse {}
message GetBlockSizeSoftLimitRequest {}
message GetBlockSizeSoftLimitResponse {}
message SetBlockSizeSoftLimitRequest {}
message SetBlockSizeSoftLimitResponse {}
message GetTreasuryWhitelistRequest {}
message GetTreasuryWhitelistResponse {}
message WhitelistTreasuryTransactionRequest {}
message WhitelistTreasuryTransactionResponse {}
message ReconsiderBlockRequest {}
message ReconsiderBlockResponse {}
message RecomputeChainStateRequest {}
message RecomputeChainStateResponse {}

// NOTIFICATIONS

message TransactionNotification {
    // State of the transaction acceptance.
    enum Type {
        // A transaction in mempool.
        UNCONFIRMED = 0;
        // A transaction in a finalized block.
        FINALIZED   = 1;
    }

    // Whether or not the transaction has been included in a block.
    Type type = 1;
    oneof transaction {
        // A transaction included in a block.
        Transaction finalized_transaction          = 2;
        // A transaction in mempool.
        MempoolTransaction unconfirmed_transaction = 3;
    }
}

message BlockNotification {
    // The BlockInfo (including header data) for the block
    BlockInfo block_info                  = 1;
    // The blocks transactions (if requested).
    //
    // The transactions will either be returned in for or just the txids depending
    // on the request.
    repeated TransactionData transactions = 2;
}

// DATA MESSAGES

message MempoolTransaction {
    Transaction transaction = 1;
    // The time when the transaction was added too the pool.
    int64 added_time = 2;
    // The block height when the transaction was added to the pool.
    int32 added_height = 3;
    // The total fee the transaction pays.
    int64 fee = 4;
    // The fee per kilobyte the transaction pays.
    int64 fee_per_kilobyte = 5;
}

message TransactionData {
    oneof txids_or_txs {
        // Just the transaction ID
        bytes transaction_hash = 1;
        // A marshaled transaction.
        Transaction transaction = 2;
    }
}

message BlockInfo {
    // The hash of the block header.
    bytes  block_ID   = 1;
    // A version number to track software/protocol upgrades.
    uint32 version    = 2;
    // The height of the block in the chain.
    uint32 height     = 3;
    // The block in the chain right before this one.
    bytes parent      = 4;
    // The next block in the chain (or nil if this block is the tip).
    bytes child       = 5;
    // The timestamp of the block. Expressed in seconds since 1970-01-01.
    int64 timestamp   = 6;
    // The root of the Merkle Tree built from all transactions in the block.
    bytes tx_root     = 7;
    // The peerID of the validator that created the block.
    bytes producer_ID = 8;
    // The size of the block in bytes.
    uint32 size       = 9;
    // The number of transactions in the block.
    uint32 num_txs    = 10;
}

message Validator {
        // The validator ID encoded in bytes.
        bytes validator_ID        = 1;
        // The number of coins staked by this validator.
        uint64 total_stake        = 2;
        // The nullifiers for the utxos the validator has staked.
        repeated bytes nullifiers = 3;
        // The total of any unclaimed validator rewards.
        uint64 unclaimed_coins    = 4;
        // The number of blocks this validator has created this epoch.
        uint32 epoch_blocks       = 5;
}