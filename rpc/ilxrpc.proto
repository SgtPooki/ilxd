syntax = "proto3";
option go_package="github.com/project-illium/ilxd/rpc/pb";

package pb;

import "transactions.proto";
import "blocks.proto";

service BlockchainService {
    // GetMempoolInfo returns the state of the current mempool
    rpc GetMempoolInfo(GetMempoolInfoRequest) returns (GetMempoolInfoResponse) {}

    // GetMempool returns all the transactions in the mempool
    rpc GetMempool(GetMempoolRequest) returns (GetMempoolResponse) {}

    // GetBlockchainInfo returns data about the blockchain including the most recent
    // block hash and height.
    rpc GetBlockchainInfo(GetBlockchainInfoRequest) returns (GetBlockchainInfoResponse) {}

    // GetBlockInfo returns a BlockHeader plus some extra metadata.
    rpc GetBlockInfo(GetBlockInfoRequest)returns (GetBlockInfoResponse) {}

    // GetBlock returns the detailed data for a block.
    rpc GetBlock(GetBlockRequest) returns (GetBlockResponse) {}

    // GetCompressedBlock returns a block that is stripped down to just the outputs.
    // It is the bare minimum information a client side wallet needs to compute its internal
    // state.
    rpc GetCompressedBlock(GetCompressedBlockRequest) returns (GetCompressedBlockResponse) {}

    // GetHeaders returns a batch of headers according to the request parameters.
    rpc GetHeaders(GetHeadersRequest) returns (GetHeadersResponse) {}

    // GetCompressedBlocks returns a batch of CompressedBlocks according to the request parameters.
    rpc GetCompressedBlocks(GetCompressedBlocksRequest) returns (GetCompressedBlocksResponse) {}

    // GetTransaction returns the transaction for the given transaction ID.
    //
    // **Requires TxIndex**
    rpc GetTransaction(GetTransactionRequest) returns (GetTransactionResponse) {}

    // GetMerkleProof returns a Merkle (SPV) proof for a specific transaction
    // in the provided block.
    //
    // **Requires TxIndex**
    rpc GetMerkleProof(GetMerkleProofRequest) returns (GetMerkleProofResponse) {}

    // GetValidator returns all the information about the given validator including number
    // of staked coins.
    rpc GetValidator(GetValidatorRequest) returns (GetValidatorResponse) {}

    // GetValidatorSetInfo returns information about the validator set.
    rpc GetValidatorSetInfo(GetValidatorSetInfoRequest) returns (GetValidatorSetInfoResponse) {}

    // GetValidatorSet returns all the validators in the current validator set.
    rpc GetValidatorSet(GetValidatorSetRequest) returns (GetValidatorSetResponse) {}

    // GetAccumulatorCheckpoint returns the accumulator at the requested height.
    // If there is no checkpoint at that height, the *next* checkpoint found in the
    // chain will be returned.
    rpc GetAccumulatorCheckpoint(GetAccumulatorCheckpointRequest) returns (GetAccumulatorCheckpointResponse) {}

    // SubmitTransaction validates a transaction and submits it to the network. An error will be returned
    // if it fails validation.
    rpc SubmitTransaction(SubmitTransactionRequest) returns (SubmitTransactionResponse) {}

    // SubscribeBlocks returns a stream of notifications when new blocks are finalized and
    // connected to the chain.
    rpc SubscribeBlocks(SubscribeBlocksRequest) returns (stream BlockNotification) {}
}

service WalletServerService {
    // RegisterViewKey registers a new view key with the server. The server will use this key when
    // attempting to decrypt each output. If outputs decrypt, they will be indexed so the client
    // can fetch them later.
    //
    // To free up resources keys will automatically unregister after some time if the wallet has not
    // connected in some time.
    rpc RegisterViewKey(RegisterViewKeyRequest) returns (RecomputeChainStateResponse) {}

    // SubscribeTransactions subscribes to a stream of TransactionsNotifications that match to the
    // provided view key.
    rpc SubscribeTransactions(SubscribeTransactionsRequest) returns (stream TransactionNotification) {}

    // GetWalletTransactions returns a list of transactions for the provided view key.
    rpc GetWalletTransactions(GetWalletTransactionsRequest) returns (GetWalletTransactionsResponse) {}

    // GetTxoProof returns the merkle inclusion proof for the given commitment. This information is needed
    // by the client to create the zero knowledge proof needed to spend the transaction.
    rpc GetTxoProof(GetTxoProofRequest) returns (GetTxoProofResponse) {}
}

service WalletService {
    // GetBalance returns the combined balance of all addresses in the wallet
    rpc GetBalance(GetBalanceRequest) returns (GetBalanceResponse) {}

    // GetWalletSeed returns the mnemonic seed for the wallet. If the wallet
    // seed has been deleted via the `DeletePrivateKeys` RPC an error will be
    // returned.
    //
    // **Requires wallet to be unlocked**
    rpc GetWalletSeed(GetWalletSeedRequest) returns (GetWalletSeedResponse) {}

    // GetAddresses returns all the addresses created by this wallet
    rpc GetAddresses(GetAddressesRequest) returns (GetAddressesResponse) {}

    // GetNewAddress generates a new address and returns it. Both a new spend key
    // and view key will be derived from the mnemonic seed.
    rpc GetNewAddress(GetNewAddressRequest) returns (GetNewAddressResponse) {}

    // GetTransactions returns the list of transactions for the wallet
    rpc GetTransactions(GetTransactionsRequest) returns (GetTransactionsResponse) {}

    // GetUtxos returns a list of the wallet's current unspent transaction outputs (UTXOs)
    rpc GetUtxos(GetUtxosRequest) returns (GetUtxosResponse) {}

    // GetPrivateKeys returns the spend and view keys for the given address
    //
    // **Requires wallet to be unlocked**
    rpc GetPrivateKeys(GetPrivateKeysRequest) returns (GetPrivateKeysResponse) {}

    // ImportAddress imports an address into the wallet. Options are available to control whether
    // or not, and from what height, the wallet rescans the chain to discover the address' transactions.
    rpc ImportAddress(ImportAddressRequest) returns (ImportAddressResponse) {}

    // CreateMultisigAddress generates a new multisig address using the provided public keys
    rpc CreateMultisigAddress(CreateMultisigAddressRequest) returns (CreateMultisigAddressResponse) {}

    // CreateMultiSignature generates and returns a signature for use when proving a multisig transaction
    rpc CreateMultiSignature(CreateMultiSignatureRequest) returns (CreateMultiSignatureResponse) {}

    // ProveMultisig creates a proof for a transaction with a multisig input
    rpc ProveMultisig(ProveMultisigRequest) returns (ProveMultisigResponse) {}

    // WalletLock encrypts the wallet's private keys
    rpc WalletLock(WalletLockRequest) returns (WalletLockResponse) {}

    // WalletUnlock decrypts the wallet seed and holds it in memory for the specified period of time
    rpc WalletUnlock(WalletUnlockRequest) returns (WalletUnlockResponse) {}

    // ChangeWalletPassphrase changes the passphrase used to encrypt the wallet private keys
    rpc ChangeWalletPassphrase(ChangeWalletPassphraseRequest) returns (ChangeWalletPassphraseResponse) {}

    // DeletePrivateKeys deletes the wallet's private keys and seed from disk essentially turning the wallet
    // into a watch-only wallet. It will still record incoming transactions but cannot spend them.
    //
    // **Requires wallet to be unlocked**
    rpc DeletePrivateKeys(DeletePrivateKeysRequest) returns (DeletePrivateKeysResponse) {}

    // CreateRawTransaction creates a new, unsigned (unproven) transaction using the given parameters
    rpc CreateRawTransaction(CreateRawTransactionRequest) returns (CreateRawTransactionResponse) {}

    // ProveRawTransaction creates the zk-proof for the transaction. Assuming there are no errors, this
    // transaction should be ready for broadcast.
    rpc ProveRawTransaction(ProveRawTransactionRequest) returns (ProveRawTransactionRequest) {}

    // BroadcastRawTransaction broadcasts a raw transaction to the network
    rpc BroadcastRawTransaction(BroadcastRawTransactionRequest) returns (BroadcastRawTransactionResponse) {}

    // Stake stakes the selected wallet UTXOs and turns the node into a validator
    //
    // **Requires wallet to be unlocked**
    rpc Stake(StakeRequest) returns (StakeResponse) {}

    // SetAutoStakeRewards make it such that any validator rewards that are earned are automatically staked
    //
    // **Requires wallet to be unlocked**
    rpc SetAutoStakeRewards(SetAutoStakeRewardsRequest) returns (SetAutoStakeRewardsResponse) {}

    // Spend sends coins from the wallet according to the provided parameters
    //
    // **Requires wallet to be unlocked**
    rpc Spend(SpendRequest) returns (SpendResponse) {}
}

service NodeService {
    // GetHostInfo returns info about the libp2p host
    rpc GetHostInfo(GetHostInfoRequest) returns (GetHostInfoResponse) {}

    // GetPeers returns a list of peers that this node is connected to
    rpc GetPeers(GetPeersRequest) returns (GetPeersResponse) {}

    // AddPeer attempts to connect to the provided peer
    rpc AddPeer(AddPeerRequest) returns (AddPeerResponse) {}

    // BlockPeer blocks the given peer for the provided time period
    rpc BlockPeer(BlockPeerRequest) returns (BlockPeerResponse) {}

    // SetLogLevel changes the logging level of the node
    rpc SetLogLevel(SetLogLevelRequest) returns (SetLogLevelResponse) {}

    // GetMinFeePerKilobyte returns the node's current minimum transaction fee needed to relay
    // transactions and admit them into the mempool. Validators will also set their initial preference
    // for blocks containing transactions with fees below this threshold to not-preferred.
    rpc GetMinFeePerKilobyte(GetMinFeePerKilobyteRequest) returns (GetMinFeePerKilobyteResponse) {}

    // SetMinFeePerKilobyte sets the node's fee policy
    rpc SetMinFeePerKilobyte(SetMinFeePerKilobyteRequest) returns (SetMinFeePerKilobyteResponse) {}

    // GetMinStake returns the node's current minimum stake policy. Stake transactions staking less than
    // this amount will not be admitted into the mempool and will not be relayed. Validators will also
    // set their initial preference for blocks containing stake transactions below this threshold to
    // not-preferred.
    rpc GetMinStake(GetMinStakeRequest) returns (GetMinStakeResponse) {}

    // SetMinStake sets the node's minimum stake policy
    rpc SetMinStake(SetMinStakeRequest) returns (SetMinStakeResponse) {}

    // GetBlockSizeSoftLimit returns the node's current blocksize soft limit. Validators will also
    // set their initial preference for blocks over this size to not-preferred.
    rpc GetBlockSizeSoftLimit(GetBlockSizeSoftLimitRequest) returns (GetBlockSizeSoftLimitResponse) {}

    // SetBlockSizeSoftLimit sets the node's blocksize soft limit policy.
    rpc SetBlockSizeSoftLimit(SetBlockSizeSoftLimitRequest) returns (SetBlockSizeSoftLimitResponse) {}

    // GetTreasuryWhitelist returns the current treasury whitelist for the node. Blocks containing
    // TreasuryTransactions not found in this list will have their initial preference set to not-preferred.
    rpc GetTreasuryWhitelist(GetTreasuryWhitelistRequest) returns (GetTreasuryWhitelistResponse) {}

    // UpdateTreasuryWhitelist adds or removes a transaction to from the treasury whitelist
    rpc UpdateTreasuryWhitelist(UpdateTreasuryWhitelistRequest) returns (UpdateTreasuryWhitelistResponse) {}

    // ReconsiderBlock tries to reprocess the given block
    rpc ReconsiderBlock(ReconsiderBlockRequest) returns (ReconsiderBlockResponse) {}

    // RecomputeChainState deletes the accumulator, validator set, and nullifier set and rebuilds them by
    // loading and re-processing all blocks from genesis.
    rpc RecomputeChainState(RecomputeChainStateRequest) returns (RecomputeChainStateResponse) {}
}

// RPC MESSAGES

// BlockchainService
message GetMempoolInfoRequest{}
message GetMempoolInfoResponse {
    // The count of transactions in the mempool
    uint32 size  = 1;
    // The size in bytes of all transactions in the mempool
    uint32 bytes = 2;
}

message GetMempoolRequest {
    // When `full_transactions` is true, full transaction data is provided
    // instead of just transaction hashes. Default is false.
    bool full_transactions = 1;
}
message GetMempoolResponse {
    // List of unconfirmed transactions.
    repeated TransactionData transaction_data = 1;
}

message GetBlockchainInfoRequest {}
message GetBlockchainInfoResponse {
    // Illium network types
    enum Network {
        // Live public network with monetary value
        MAINNET  = 0;
        // An isolated environment for automated testing
        REGTEST  = 1;
        // A public environment where monetary value is agreed to be zero,
        // and some checks for transaction conformity are disabled.
        TESTNET  = 2;
    }

    // Which network the node is operating on
    Network network          = 1;
    // The current number of blocks in the chain
    uint32 best_height        = 2;
    // The hash of the best (tip) block in the chain
    bytes best_block_ID      = 3;
    // The timestamp of the best block
    int64 block_time         = 4;
    // When `tx_index` is true, the node has full transaction index enabled
    bool tx_index            = 5;
    // The total number of coins in circulation
    uint64 ciculating_supply = 6;
    // The total number of coins staked
    uint64 total_staked      = 7;
}

message GetBlockInfoRequest {
    oneof id_or_height {
        // The block hash as a byte array or hex encoded string
        bytes block_ID = 1;
        // The block number
        uint32 height   = 2;
    }
}
message GetBlockInfoResponse {
    // Marshaled block header data, as well as metadata
    BlockInfo info = 1;
}

message GetBlockRequest {
    oneof id_or_height {
        // The block hash as a byte array or hex encoded string
        bytes block_ID = 1;
        // The block number
        uint32 height   = 2;
    }
}
message GetBlockResponse {
    // The full block response
    Block block = 1;
}

message GetCompressedBlockRequest {
    oneof id_or_height {
        // The block hash as a byte array or hex encoded string
        bytes block_ID = 1;
        // The block number
        uint32 height   = 2;
    }
}
message GetCompressedBlockResponse {
    // The compressed block contains only transaction outputs
    CompressedBlock block = 1;
}

message GetHeadersRequest {
    // The height to start receiving headers
    uint32 start_height = 1;
    // The last header height to return. Note that a maximum of 2000
    // blocks will be returned per request. If end_height is > start_height + 1999
    // then end_height will be set set to start_height + 1999 and 2000 headers
    // will be returned. If end_height is past the tip of the chain the headers
    // will be returned up to the tip.
    //
    // If end_height is less than start_height 2000 headers will be returned.
    uint32 end_height   = 2;
}
message GetHeadersResponse {
    repeated BlockHeader headers = 1;
}

message GetCompressedBlocksRequest {
    // The height to start receiving headers
    uint32 start_height = 1;
    // The last block height to return. Note that a maximum of 2000 blocks will be returned
    // per request. If end_height is > start_height + 1999 then end_height will be set set
    // to start_height + 1999 and 2000 compressed blocks will be returned. If end_height is
    // past the tip of the chain the compressed blocks will be returned up to the tip.
    //
    // If end_height is less than start_height 2000 blocks will be returned.
    uint32 end_height   = 2;
}
message GetCompressedBlocksResponse {
    // The compressed block response
    repeated CompressedBlock blocks = 1;
}

message GetTransactionRequest {
    // A transaction hash
    bytes transaction_ID = 1;
}
message GetTransactionResponse {
    // The transaction response
    Transaction tx = 1;
}

message GetMerkleProofRequest {
    // A transaction hash
    bytes transaction_ID = 1;
}
message GetMerkleProofResponse {
    // Block header information for the corresponding transaction
    BlockInfo block       = 1;
    // A list containing the transaction hash, the adjacent leaf transaction hash
    // and the hashes of the highest nodes in the merkle tree not built with the transaction.
    // Proof hashes are ordered following transaction order, or left to right on the merkle tree
    repeated bytes hashes = 2;
    // The least significant bit in flags corresponds to the last hash in `hashes`. The second least
    // significant to the second to last hash, and so on. The bit signifies whether the hash should be
    // prepended (0) or appended (1) when hashing each level in the tree.
    uint32 flags = 3;
}

message GetValidatorRequest {
    // A serialized validator ID
    bytes validator_ID = 1;
}
message GetValidatorResponse {
    // The validator response
    Validator validator = 1;
}

message GetValidatorSetInfoRequest{}
message GetValidatorSetInfoResponse{
    // The total number of coins staked on the network
    uint64 total_staked   = 1;
    // The total number of validators on the network
    uint32 num_validators = 2;
}

message GetValidatorSetRequest{}
message GetValidatorSetResponse{
    // The full list of validators on the network
    repeated Validator validators = 1;
}

message GetAccumulatorCheckpointRequest{
    // The height of the accumulator checkpoint to return.
    // If there is no checkpoint at that height, the *next*
    // checkpoint found in the chain will be returned.
    //
    // An error will be returned if there is no checkpoint after
    // the provided height.
    uint32 height = 1;
}
message GetAccumulatorCheckpointResponse{
    // The height of the checkpoint
    uint32 height              = 1;
    // The number of entries in the accumulator at this checkpoint
    uint64 num_entries         = 2;
    // The accumulator hashes
    repeated bytes accumulator = 3;
}

message SubmitTransactionRequest {
    // The transaction to submit to the network
    Transaction transaction = 1;
}
message SubmitTransactionResponse {
    // The transaction ID of the transaction.
    //
    // If submission was unsuccessful and error will be returned.
    bytes transaction_ID = 1;
}

message SubscribeBlocksRequest {
    // When full_block is true, a complete marshaled block is sent.
    // Default is false, block metadata is sent. See `BlockInfo`.
    bool full_block        = 1;

    // When full_transactions is true, provide full transaction info
    // for a marshaled block.
    //
    // Default is false, only the transaction IDs are included for
    // a marshaled block.
    bool full_transactions = 2;
}

// WalletServerService
message RegisterViewKeyRequest {
    // A view key to register with the server.
    string view_key = 1;

    // The date the address was created. The server will scan historical blocks
    // for matching transactions from the birthday forward. Please don't use an
    // earlier birthday than needed as it puts more stress on the server.
    int64 birthday = 2;
}
message RegisterViewKeyResponse {}

message SubscribeTransactionsRequest {
    // A list of view keys to subscribe to
    repeated string view_keys   = 1;

    // When include_mempool is true, new unconfirmed transactions from mempool are
    // included apart from the ones finalized in a block.
    bool include_mempool        = 2;

    // When include_in_block is true, transactions are included when they are finalized.
    // This notification is sent in addition to any requested mempool notifications.
    bool include_in_block       = 3;
}

message GetWalletTransactionsRequest{
    // The view key to query transactions
    string view_key = 1;

    // The number of transactions to skip, starting with the oldest first.
    // Does not affect results of unconfirmed transactions.
    uint32 nb_skip = 2;
    // Specify the number of transactions to fetch.
    uint32 nb_fetch = 3;


    oneof start_block {
        // Recommended. Only get transactions after (or within) a
        // starting block identified by hash.
        bytes block_ID = 4;
        // Recommended. Only get transactions after (or within) a
        // starting block identified by block number.
        int32 height = 5;
    }
}
message GetWalletTransactionsResponse {
    // A list of transactions as the response
    repeated Transaction transactions = 1;
}

message GetTxoProofRequest {
    // The output commitment to fetch the txo proof for
    bytes commitment = 1;
}
message GetTxoProofResponse {
    // The proof response
    TxoProof proof = 1;
}

// WalletService
message GetBalanceRequest {}
message GetBalanceResponse {
    // Balance response
    uint64 balance = 1;
}

message GetWalletSeedRequest {}
message GetWalletSeedResponse {
    // The wallet's mnemonic seed
    string mnemonic_seed = 1;
}
message GetAddressesRequest {}
message GetAddressesResponse {
    // The most recent address generated by the wallet
    string address = 1;
}
message GetNewAddressRequest {}
message GetNewAddressResponse {
    // A fresh address generated by the wallet
    string address = 1;
}
message GetTransactionsRequest {
    // Transaction ID as a byte array or hex encoded string
    bytes transaction_ID = 1;
}
message GetTransactionsResponse {
    // Returned transaction
    Transaction tx = 1;
}
message GetUtxosRequest {}
message GetUtxosResponse {
    // The full list of utxos in the wallet
    repeated Utxo utxos = 1;
}

message GetPrivateKeysRequest {
    // The address to fetch private keys for
    string address = 1;
}
message GetPrivateKeysResponse {
    // The spend private key
    bytes spend_key = 1;
    // The view private key
    bytes view_key  = 2;
}

message ImportAddressRequest {
    // The address to import
    string address          = 1;

    // The spend and view private keys are optional. If they
    // are nil then this address will essentially be watch-only
    // and the wallet will not be able to spend from it.
    bytes spend_key         = 2;
    bytes view_key          = 3;

    // Should the wallet rescan the blockchain looking for
    // transactions for this address.
    bool rescan             = 4;
    // If so what height should it start the rescan.
    uint32 rescanFromHeight = 5;
}
message ImportAddressResponse {}

message CreateMultisigAddressRequest {
    // A list of public keys to use for the multisig address
    repeated bytes pubkeys = 1;
    // The number of keys required to sign the tranaction to
    // release the funds.
    uint32 threshold       = 2;

    // A view key to use with the address
    bytes view_pubkey      = 3;
}
message CreateMultisigAddressResponse {
    // Multisig address response
    string address = 1;
}

message CreateMultiSignatureRequest {
    oneof tx_or_sighash {
        // Either provide the transaction so the sighash can be computed
        Transaction tx = 1;
        // Or just provide the sighash itself
        bytes sighash  = 2;
    }

    // A private key to sign with
    bytes private_key = 3;
}
message CreateMultiSignatureResponse {
    // A signature covering the sighash
    bytes signature = 1;
}

message ProveMultisigRequest {
    // A transaction to prove. This RPC requires there to be only one
    // input and that the input be a multisig script.
    RawTransaction tx   = 1;

    // A list of signatures. Each one must cover the transaction's sighash.
    repeated bytes sigs = 2;
}
message ProveMultisigResponse {
    // A full transaction with the proof attached
    Transaction proved_tx = 1;
}
message WalletLockRequest {}
message WalletLockResponse {}

message WalletUnlockRequest {
    // The wallet passphrase used to decrypt
    string passphrase = 1;
    // The duration (in seconds) to leave the wallet decrypted for.
    // It will automatically be re-encrypted after the duration passes.
    uint32 duration = 2;
}
message WalletUnlockResponse {}

message ChangeWalletPassphraseRequest {
    // Current passphrase
    string current_passphrase = 1;
    // Passphrase to change it to
    string new_passphrase     = 2;
}
message ChangeWalletPassphraseResponse {}

message DeletePrivateKeysRequest {}
message DeletePrivateKeysResponse {}

message CreateRawTransactionRequest {
    // A list of either utxo commitments or private inputs
    repeated Input inputs     = 1;
    // A list of outputs to send coins to
    repeated Output outputs   = 2;
    // A bool to control whether the wallet will automatically append a
    // change output and send the remainder of the coins (minus a fee)
    // to the change output.
    bool append_change_output = 3;
    // If append_change_output is true you can specify the fee amount to use.
    // If zero the wallet will use its internal fee policy.
    uint64 fee_per_kilobyte   = 4;

    message Input {
        oneof commitment_or_private_input {
            // This is a utxo commitment known to the wallet
            bytes commitment = 1;
            // If trying to create a transaction spending a utxo that the
            // wallet does not know about you must provide the full private
            // input data.
            PrivateInput input = 2;
        }
    }

    message Output {
        // Address to send coins to
        string address = 1;
        // The amount to send
        uint64 amount  = 2;
    }
}
message CreateRawTransactionResponse {
    // Raw transaction response
    RawTransaction tx = 1;
}

message ProveRawTransactionRequest {
    // The raw transaction to prove
    RawTransaction tx = 1;
    // The private keys to use to prove the inputs.
    repeated bytes private_keys = 2;
}
message ProveRawTransactionResponse {
    // A full transaction with the proof attached
    Transaction proved_tx = 1;
}

message BroadcastRawTransactionRequest {
    // A fully proven transaction
    Transaction tx = 1;
}
message BroadcastRawTransactionResponse {}

message StakeRequest {
    // The utxos to stake identified by their commitment hashes
    repeated bytes commitments = 1;
}
message StakeResponse {}

message SetAutoStakeRewardsRequest {
    // Whether to turn on or off autostaking
    bool autostake = 1;
}
message SetAutoStakeRewardsResponse {}

message SpendRequest {
    // Address to send funds to
    string to_address       = 1;
    // Amount to send
    uint64 amount           = 2;
    // The fee to use for the transaction.
    // If zero the wallet will use its internal fee policy.
    uint64 fee_per_kilobyte = 3;
}
message SpendResponse {}

// NodeService
message GetHostInfoRequest {}
message GetHostInfoResponse {
    // The host peer ID
    string peer_ID        = 1;
    // A list of multiaddrs that this node is listening on
    repeated string addrs = 2;
    // The number of peers this node is connected to
    uint32 peers    = 3;
    // Is tx index enabled
    bool tx_index         = 4;
    // Is the wallet server enabled
    bool wallet_server    = 5;
}

message GetPeersRequest {}
message GetPeersResponse {
    // List of peers
    repeated Peer peers = 1;
}

message AddPeerRequest {
    // The peer addr to add. This must be in multiaddr format and include
    // the /p2p/<peerID> field.
    // Ex) /ip4/167.172.126.176/tcp/4001/p2p/12D3KooWHnpVyu9XDeFoAVayqr9hvc9xPqSSHtCSFLEkKgcz5Wro
    string addr = 1;
}
message AddPeerResponse {}

message BlockPeerRequest {
    // Peer ID to block
    string peer_ID = 1;
}
message BlockPeerResponse {}

message SetLogLevelRequest {
    // The debug level to set the logging to
    Level level = 1;

    enum Level {
       DEBUG     = 0;
       INFO      = 1;
       WARNING   = 2;
       ERROR     = 3;
       CRITICAL  = 4;
       ALERT     = 5;
       EMERGENCY = 6;
    }
}
message SetLogLevelResponse {}

message GetMinFeePerKilobyteRequest {}
message GetMinFeePerKilobyteResponse {
    // Fee per kilobyte response
    uint64 fee_per_kilobyte = 1;
}

message SetMinFeePerKilobyteRequest {
    // Fee per byte to set
    uint64 fee_per_kilobyte = 1;
}
message SetMinFeePerKilobyteResponse {}

message GetMinStakeRequest {}
message GetMinStakeResponse {
    // Minimum stake response
    uint64 min_stake_amount = 1;
}

message SetMinStakeRequest {
    // Minimum stake amount to set
    uint64 min_stake_amount = 1;
}
message SetMinStakeResponse {}

message GetBlockSizeSoftLimitRequest {}
message GetBlockSizeSoftLimitResponse {
    // Block size response
    uint32 block_size = 1;
}

message SetBlockSizeSoftLimitRequest {
    // Blocksize to set
    uint32 block_size = 1;
}
message SetBlockSizeSoftLimitResponse {}

message GetTreasuryWhitelistRequest {}
message GetTreasuryWhitelistResponse {
    // Whitelisted txids
    repeated bytes txids = 1;
}

message UpdateTreasuryWhitelistRequest {
    // Txids to add to the whitelist
    repeated bytes add    = 1;
    // Txids to remove from the whitelist
    repeated bytes remove = 2;
}
message UpdateTreasuryWhitelistResponse {}

message ReconsiderBlockRequest {
    // Block ID to reconsider.
    bytes block_ID = 1;

    // We likely don't have the block and will have to download it from
    // another peer. You can set the peer here. If empty we will try to find
    // it form a few random peers.
    string download_peer = 2;
}
message ReconsiderBlockResponse {}

message RecomputeChainStateRequest {}
message RecomputeChainStateResponse {}

// NOTIFICATIONS

message TransactionNotification {
    // State of the transaction acceptance.
    enum Type {
        // A transaction in mempool.
        UNCONFIRMED = 0;
        // A transaction in a finalized block.
        FINALIZED   = 1;
    }

    // Whether or not the transaction has been included in a block.
    Type type = 1;
    oneof transaction {
        // A transaction included in a block.
        Transaction finalized_transaction          = 2;
        // A transaction in mempool.
        MempoolTransaction unconfirmed_transaction = 3;
    }
}

message BlockNotification {
    // The BlockInfo (including header data) for the block
    BlockInfo block_info                  = 1;
    // The blocks transactions (if requested).
    //
    // The transactions will either be returned in for or just the txids depending
    // on the request.
    repeated TransactionData transactions = 2;
}

// DATA MESSAGES

message MempoolTransaction {
    Transaction transaction = 1;
    // The time when the transaction was added too the pool.
    int64 added_time = 2;
    // The block height when the transaction was added to the pool.
    int32 added_height = 3;
    // The total fee the transaction pays.
    int64 fee = 4;
    // The fee per kilobyte the transaction pays.
    int64 fee_per_kilobyte = 5;
}

message TransactionData {
    oneof txids_or_txs {
        // Just the transaction ID
        bytes transaction_ID    = 1;
        // A marshaled transaction.
        Transaction transaction = 2;
    }
}

message BlockInfo {
    // The hash of the block header.
    bytes  block_ID   = 1;
    // A version number to track software/protocol upgrades.
    uint32 version    = 2;
    // The height of the block in the chain.
    uint32 height     = 3;
    // The block in the chain right before this one.
    bytes parent      = 4;
    // The next block in the chain (or nil if this block is the tip).
    bytes child       = 5;
    // The timestamp of the block. Expressed in seconds since 1970-01-01.
    int64 timestamp   = 6;
    // The root of the Merkle Tree built from all transactions in the block.
    bytes tx_root     = 7;
    // The peerID of the validator that created the block.
    bytes producer_ID = 8;
    // The size of the block in bytes.
    uint32 size       = 9;
    // The number of transactions in the block.
    uint32 num_txs    = 10;
}

message Validator {
        // The validator ID encoded in bytes.
        bytes validator_ID        = 1;
        // The number of coins staked by this validator.
        uint64 total_stake        = 2;
        // The nullifiers for the utxos the validator has staked.
        repeated bytes nullifiers = 3;
        // The total of any unclaimed validator rewards.
        uint64 unclaimed_coins    = 4;
        // The number of blocks this validator has created this epoch.
        uint32 epoch_blocks       = 5;
}

message Utxo {
    // The commitment associated with the output
    bytes commitment = 1;
    // The amount of coins
    uint64 amount    = 2;
    // The address that the utxo is associated with
    string address   = 3;
}

message RawTransaction {
    // The transaction as it appears on the network
    Transaction tx                 = 1;
    // The private (hidden) data for each input
    repeated PrivateInput inputs   = 2;
    // The private (hidden) data for each output
    repeated PrivateOutput outputs = 3;
}

message PrivateInput {
    // The amount of the input
    uint64 amount                   = 1;
    // Input salt
    bytes salt                      = 2;
    // Input asset ID
    bytes asset_ID                  = 3;
    // Input state
    bytes state                     = 4;
    // The unlocking function commitment
    bytes unlocking_script_hash     = 5;
    // The unlocking function parameters
    repeated bytes unlocking_params = 6;
    // The txo proof linking the input
    // commitment to the accumulator
    TxoProof txo_proof              = 7;
}

message PrivateOutput {
    // Output amount
    uint64 amount     = 1;
    // Output salt
    bytes salt        = 2;
    // Output asset ID
    bytes asset_ID    = 3;
    // Output state
    bytes state       = 4;
    // Output scriptHash
    bytes script_hash = 5;
}

message TxoProof {
    // The commitment this inclusion proof is for
    bytes commitment           = 1;
    // The hashes that form the root preimage
    repeated bytes accumulator = 2;
    // The merkle hashes linking the commitment to the accumulator
    repeated bytes hashes      = 3;
    // Flags indicate whether a hash in the hash list is left or right.
    // 0 == left, 1 == right.
    uint64 flags               = 4;
    // The index of this commitment in the tree
    uint64 index               = 5;
}

message Peer {
    // Peer ID
    string id             = 1;
    // Multiaddrs
    repeated string addrs = 2;
}