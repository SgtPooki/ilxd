(lambda (priv pub) (
        letrec (
               ;; cat-and-hash takes two integers, each up to 254 bits.
               ;; The integers are converted to their byte representation,
               ;; concatenated together, then hashed with blake2s. The two
               ;; most significant bits of the output are dropped.
               (cat-and-hash (lambda (a b)
                    (eval (cons 'coproc_blake2s (cons a (cons b nil))))))

               ;; map-get returns an item from a map given the key.
               ;; the map must be a list of form (:key item :key item).
               (map-get (lambda (key plist)
                    (if plist
                       (if (eq key (car plist))
                           (car (cdr plist))
                           (map-get key (cdr (cdr plist))))
                       nil)))

               ;; map-update updates value of the given key in the
               ;; provided map and returns the new map.
               ;; If the key is not in the map a new map entry will
               ;; be added.
               ;; The map is formatted as a flat list of format
               ;; (:key item :key item)
               (map-update (lambda (key value map)
                    (if (eq map nil)
                        (cons key (cons value nil))
                        (let ((existing-key (car map))
                              (rest-map (cdr map)))
                              (if (= existing-key key)
                                  (cons key (cons value (cdr (cdr map))))
                                  (cons existing-key (map-update key value rest-map)))))))

               ;; check-overflow returns whether the sum of a and b overflows a u64
               (check-overflow (lambda (a b)
                   (if (> b 0)
                       (if (> a (- 18446744073709551615 b))
                           t
                           nil)
                       nil)))

               ;; validate-inclusion-proof validates that the provided
               ;; output commitment connects to the provided merkle root
               ;; via a merkle inclusion proof.
               (validate-inclusion-proof (lambda (leaf hashes root)
                   (letrec (
                       (hash-branches (lambda (h hashes)
                           (let ((next-hash (car hashes))
                                (val (car next-hash))
                                (new-h (if (cdr next-hash)
                                      (cat-and-hash h val)
                                      (cat-and-hash val h))))

                              (if (cdr hashes)
                                  (hash-branches new-h (cdr hashes))
                                  new-h)))))

                       (= (hash-branches leaf hashes) root))))

               ;; validate-output validates that the provided private output
               ;; data matches the public output commitment found in the
               ;; transaction.
               (validate-outputs (lambda (private-outputs public-outputs asset-map)
                    (let ((priv-out (car private-outputs))
                          (pub-out (car public-outputs))
                          (amount (car (cdr priv-out)))
                          (asset-id (car (cdr (cdr priv-out))))
                          (asset-sum (map-get asset-id asset-map))
                          (asset-sum (if asset-sum asset-sum 0))
                         )
                         (if pub-out
                             (if priv-out ;; If priv and pub are both non-nil then we need to validate the public commitment
                                 (if (< amount 0)
                                     nil ;; If amount is negative return false
                                     (if (check-overflow asset-sum amount)
                                         nil ;; If overflow return false
                                         (if (= (car pub-out) (num (commit (cons (car priv-out)                                 ;; script-hash
                                                                       (cons amount                                             ;; amount
                                                                       (cons asset-id                                           ;; asset-id
                                                                       (cons (car (cdr (cdr (cdr priv-out))))                   ;; salt
                                                                       (cons (car (cdr (cdr (cdr (cdr priv-out))))) nil)))))))) ;; state
                                             (validate-outputs (cdr private-outputs) (cdr public-outputs) (map-update asset-id (+ asset-sum amount) asset-map)) ;; If validation succeeds loop through the next ouputs
                                             nil ;; Validation failed return false
                                         )
                                     )
                                 )
                                 nil ;; Length of priv and pub outputs don't match. Return false.
                             )
                             (if priv-out
                                 nil ;; Length of priv and pub outputs don't match. Return false.
                                 asset-map ;; Both priv and pub are nil, this means we hit the end of the loop without error. Return true.
                             )
                         )
                    )
               ))

               (validate-inputs (lambda (inputs idx txo-root asset-map nullifiers)
                     (if (car inputs)
                         (let (
                               (input (car inputs))
                               (locking-params (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr input))))))))))
                               (unlocking-params (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr input)))))))))))
                               (locking-func (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr input)))))))))
                               (script-commitment (num (commit locking-func)))
                               (script-hash (num (commit (cons script-commitment locking-params))))
                               (amount (car (cdr input)))
                               (asset-id (car (cdr (cdr input))))
                               (salt (car (cdr (cdr (cdr input)))))
                               (state (car (cdr (cdr (cdr (cdr input))))))
                               (output-commitment (num (commit (cons script-hash (cons amount (cons asset-id (cons salt (cons state nil))))))))
                               (asset-sum (map-get asset-id asset-map))
                               (asset-sum (if asset-sum asset-sum 0))
                               (commitment-index (car (cdr (cdr (cdr (cdr (cdr input)))))))
                               (leaf (cat-and-hash commitment-index output-commitment))
                               (hashes (car (cdr (cdr (cdr (cdr (cdr (cdr input))))))))
                               (nullifier (num (commit (cons commitment-index (cons salt (cons (cons script-commitment locking-params) nil))))))
                              )

                              ;; Make sure input amounts don't overflow. This isn't possible with
                              ;; illium coins as there will never be more than 2^60, but assets can
                              ;; potentially mint more.
                              (if (check-overflow asset-sum amount)
                                  nil
                                  ;; Validate the inclusion proof proving the input commitment exists in the txo-set.
                                  (if (validate-inclusion-proof leaf hashes txo-root)
                                      ;; Validate the user's locking script
                                      (if (locking-func locking-params unlocking-params idx priv pub)
                                          (validate-inputs (cdr inputs) (+ idx 1) txo-root (map-update asset-id (+ asset-sum amount) asset-map) (cons nullifiers (cons nullifier nil))) ;; Validation passed. Continue to the next input.
                                          nil ;; Locking script validation failed. Return false.
                                      )
                                      nil ;; Invalid inclusion proof. Return false.
                                  )
                              )
                         )
                         (cons t (cons asset-map (cons (cdr nullifiers) nil))) ;; We've reached the end of the input list without error. Return true.
                     )
               ))


               )

              ;;(car (validate-inputs (car priv) 0 (car (cdr (cdr pub))) nil nil))
              (if (validate-outputs (cdr priv) (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr pub)))))))) nil)
                  t
                  nil)
        )
)