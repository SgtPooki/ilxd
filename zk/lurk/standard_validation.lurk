(lambda (priv pub) (
        letrec (
               ;; cat-and-hash takes two integers, each up to 254 bits.
               ;; The integers are converted to their byte representation,
               ;; concatenated together, then hashed with blake2s. The two
               ;; most significant bits of the output are dropped.
               (cat-and-hash (lambda (a b)
                    (eval (cons 'coproc_blake2s (cons a (cons b nil))))))

               ;; map-get returns an item from a map given the key.
               ;; the map must be a list of form (:key item :key item).
               (map-get (lambda (key plist)
                    (if plist
                       (if (eq key (car plist))
                           (car (cdr plist))
                           (map-get key (cdr (cdr plist))))
                       nil)))

               ;; map-update updates value of the given key in the
               ;; provided map and returns the new map.
               ;; If the key is not in the map a new map entry will
               ;; be added.
               ;; The map is formatted as a flat list of format
               ;; (:key item :key item)
               (map-update (lambda (key value map)
                    (if (eq map nil)
                        (cons key (cons value nil))
                        (let ((existing-key (car map))
                              (rest-map (cdr map)))
                              (if (= existing-key key)
                                  (cons key (cons value (cdr (cdr map))))
                                  (cons existing-key (map-update key value rest-map)))))))

               ;; nth returns the item at the given index from
               ;; the list or nil if the index doesn't exist.
               (nth (lambda (idx plist)
                   (if (= idx 0)
                       (car plist)
                       (nth (- idx 1) (cdr plist)))))

               ;; check-overflow returns whether the sum of a and b overflows a u64
               (check-overflow (lambda (a b)
                   (if (> b 0)
                       (if (> a (- 18446744073709551615 b))
                           t
                           nil)
                       nil)))

               ;; validate-inclusion-proof validates that the provided
               ;; output commitment connects to the provided merkle root
               ;; via a merkle inclusion proof.
               (validate-inclusion-proof (lambda (output-commitment commitment-index hashes root)
                   (letrec (
                       (h (cat-and-hash (commitment-index output-commitment)))
                       (hash-branches (lambda (h hashes)
                           (let ((next-hash (car hashes))
                                 (val (car next-hash))
                                 (left (cdr next-hash))
                                 (new-h (if left
                                       (cat-and-hash (val h))
                                       (cat-and-hash (h val)))))

                               (if (eq (cdr hashes) nil)
                                   new-h
                                   (hash-branches new-h (cdr hashes)))))))

                       (= (hash-branches h hashes) root))))
               )

               (let (
                        (input (car priv))
                        (script-hash (nth 0 input))
                        (amount (nth 1 input))
                        (asset-id (nth 2 input))
                        (state (nth 3 input))
                        (salt (nth 4 input))
                        (commitment (num (commit (cons script-hash (cons amount (cons asset-id (cons state (cons salt nil))))))))
                    )

               (validate-inclusion-proof commitment (nth 6 input)))
       )
)