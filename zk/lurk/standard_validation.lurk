(
    letrec (
        ;; hash uses the blake2s function inside the circuit.
        ;; x is expected to be an integer of up to 255 bits.
        ;; It gets converted to its byte representation inside
        ;; the coprocessor before hashing.
        ;;
        ;; This is an expensive compution and hashing will
        ;; substantially increase proving time.
        (hash (lambda (x) (
            (eval (cons 'blake2s_hash (cons x nil))))))

        ;; cat-and-hash accepts a list of integers, each up to
        ;; 255 bits. The integers are converted to their byte
        ;; representation, concatenated together, then hashed.
        ;; If a list element is type u64 then only a 8 byte
        ;; array will be concatenated for that element.
        (cat-and-hash (lambda (list)
            (hash list)))

        ;; map-get returns an item from a map given the key.
        ;; the map must be a list of form (:key item :key item).
        (map-get (lambda (key plist)
            (if plist
                (if (eq key (car plist))
                    (car (cdr plist))
                    (map-get key (cdr (cdr plist))))
                nil)))

        ;; list-get returns the item at the given index from
        ;; the list or nil if the index doesn't exist.
        (list-get (lambda (idx plist)
            (if (= idx 0)
                (car plist)
                (list-get (- idx 1) (cdr plist)))))

        ;; list-update applies a function to each item in a
        ;; list. This provides an opportunity to update one
        ;; or more items.
        (list-update (lambda (f list)
            (if list
                (cons (f (car list))(map f (cdr list)))
                nil)))
	
        ;; validate-inclusion-proof validates that the provided
        ;; output commitment connects to the provided merkle root
        ;; via a merkle inclusion proof.
        (validate-inclusion-proof (lambda (output-commitment commitment-index hashes accumulator root)
            (letrec (
                (h (cat-and-hash output-commitment (u64 commitment-index)))
                (is-hash-in-accumulator (lambda (h accumulator)
                    (if (= h (car accumulator))
                        t
                        (if (eq (cdr accumulator) nil)
                            nil
                            (is-hash-in-accumulator h (cdr accumulator)))))))
                (hash-branches (lambda (h hashes)
                    (let ((next-hash (car hashes))
                        (val (car next-hash))
                        (left (cdr next-hash))
                        (new-h (if (left)
                                (cat-and-hash (val h))
                                (cat-and-hash (h val)))))

                        (if (eq (cdr hashes) nil)
                            new-h
                            (hash-branches new-h (cdr hashes))))))

                (if (eq (is-hash-in-accumulator (hash-branches h hashes) accumulator) nil)
                    nil
                    (= (cat_list_and_hash accumulator) root)))))

        ;; validate-input validates the input against the provided
        ;; parameters. In particular it validates that the inclusion
        ;; proof is valid, the nullifier is calculated correctly,
        ;; and the committed unlocking function executed correctly.
        (validate-input (lambda (input idx private-params public-params)
            (let (
                (txo-root (map-get :txo-root public-params))
                (nullifiers (map-get :nullifiers public-params))
                (script-commitment (map-get :script-commitment input))
                (script-params (map-get :script-params input))
                (spend-script-preimage (cons script-commitment (map-get :script-params input)))
                (script-hash (hash spend-script-preimage))
                (salt (map-get :salt input))
                (commitment-idx (map-get :commitment-idx input))
                (nullifier (cat-and-hash (
                            (u64 commitment-idx)
                            salt
                            script-commitment
                            script-params)))
                (output-commitment (cat-and-hash (
                            script-hash
                            (u64 (map-get :amount input))
                            (map-get :asset-id input)
                            (map-get :state input)
                            (map-get :salt input)))))

                (if (eq ((open script-commitment)
                        script-params
                        (map-get :unlocking-params input)
                        idx
                        private-params
                        public-params) nil)
                    nil
                    (if (eq (validate-inclusion-proof output-commitment
                                commitment-idx
                                (map-get :inclusion-proof-hashes input)
                                (map-get :inclusion-proof-acc input)
                                txo-root) nil)
                        nil
                        (= nullifier (list-get idx nullifiers)))))))

        ;; validate-output validates that the provided private output
        ;; data matches the public output commitment found in the
        ;; transaction.
        (validate-output (lambda (output idx public-outputs)
            (let (
                (commitment-preimage (cat-and-hash (
                                            (map-get :script-hash output)
                                            (u64 (map-get :amount output))
                                            (map-get :asset-id output)
                                            (map-get :state output)
                                            (map-get :salt output))))
                (output-commitment (hash commitment-preimage)))

                (= output-commitment (list-get idx public-outputs)))))


        ;; validate-amounts validates that the total private input
        ;; values do not exceed the total private output values.
        ;; It performs this check both for the illium asset ID and
        ;; for other token asset IDs. It will return false if an
        ;; integer overflow is detected.
        (validate-amounts (lambda (private-inputs private-outputs coinbase fee mint-id mint-amount)
            (letrec (
                (check-overflow (lambda (a b)
                        (if (b > 0)
                            (if (a > (- 18446744073709551615 b))
                                t
                                nil)
                            nil)))
                (validate-assets (lambda (in-map out-map)
                           (let (
                                 (out-asset (car out-map))
                                 (in-asset (map-get (car out-asset) in-map)))

                                  (if (eq out-asset nil)
                                      t
                                      (if (eq in-asset nil)
                                          (if (eq (car in-asset) mint-id)
                                              (if (check-overflow (cdr in-asset) mint-amount)
                                                  nil
                                                  (> (cdr out-asset) (+ (cdr in-asset) mint-amount)))
                                              nil)
                                          (if (> (cdr out-asset) (cdr in-asset))
                                              nil
                                              (validate-assets in-map (cdr out-map)))))
                )))
                (sum-xputs (lambda (xputs illium-sum asset-map)
                              (let (
                                    (amount (map-get :amount (car xput)))
                                    (asset-id (map-get :asset-id (car xput)))
                                    (sum-assets (lambda (asset-map asset-id amount)
                                                (let ((asset (map-get asset-id asset-map)))

                                                      (if (check-overflow (cdr asset) amount)
                                                            nil
                                                            (if (eq asset nil)
                                                                (cons asset-map (cons asset-id amount))
                                                                (list-update (lambda (entry)
                                                                    (if (= (car entry) asset-id)
                                                                    (cons asset-id (+ (cdr entry) amount))
                                                                    entry)) asset-map))))))

                                    (if (eq xputs nil)
                                        (cons illium-sum asset-map)
                                        (if (= asset-id 0)
                                            (if (eq check-overflow illium-sum amount)
                                                nil
                                                (sum-xputs (cdr xputs) (+ illium-sum amount) asset-map))
                                            (let ((new-asset-map (sum-assets asset-map asset-id amount)))
                                                (if (eq new-asset-map nil)
                                                    nil
                                                    (sum-xputs (cdr xputs) illium-sum new-asset-map)))))))))

                (in-vals (sum-xputs private-inputs 0 nil))
                (out-vals (sum-xputs private-outputs 0 nil)))

                (if (eq in-vals nil)
                    nil
                    (if (eq out-vals nil)
                        nil
                        (if (check-overflow (car in-vals) coinbase)
                            nil
                            (if (check-overflow (car out-vals) fee)
                                nil
                                (if (> (+ (car out-vals) fee) (+ (car in-vals) coinbase))
                                    nil
                                    (validate-assets (cdr in-vals) (cdr out-vals))))))))))

        ;; validate-transaction puts it all together and validates the
        ;; full illium transaction. This involves validating that the
        ;; inputs and outputs are valid and that the output amounts
        ;; are valid.
        (validate-transaction (lambda (private-params public-params)
            (letrec (
                (inputs (map-get :inputs private-params))
                (outputs (map-get :outputs private-params))
                (public-outputs (map-get :outputs public-params))
                (coinbase (map-get :coinbase public-params))
                (fee (map-get :fee public-params))
                (mint-id (map-get :mint-id public-params))
                (mint-amount (map-get :mint-amount public-params))
                (validate-inputs (lambda (idx inputs)
                        (if (eq inputs nil)
                            t
                            (if (validate-input (car inputs) idx private-params public-params)
                                (validate-inputs (+ idx 1) (cdr inputs))
                                nil))))
                (validate-outputs (lambda (idx outputs)
                        (if (eq outputs nil)
                            t
                            (if (validate-output (car outputs) idx public-outputs)
                                (validate-outputs (+ idx 1) (cdr outputs))
                                nil))))
               )

               (if (eq inputs nil)
                   nil
                   (if (validate-inputs 0 inputs)
                       (if (eq outputs nil)
                           nil
                           (if (validate-outputs 0 outputs)
                               (validate-amounts inputs outputs coinbase fee mint-id mint-amount)
                               nil))
                       nil)))))
    )

    ;; Here we call validate-transaction using the private and public params.
    ;; The private parameters are hidden behind a commitment hash such that
    ;; anyone validating this proof will only see the hash.
    (validate-tranasction (open {private_params_commitment}) {public_params})
)
