// Copyright (c) 2013-2016 The btcsuite developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package blockchain

import (
	"bytes"
	"github.com/project-illium/ilxd/params/hash"
	"github.com/project-illium/ilxd/types"
	"github.com/project-illium/ilxd/types/transactions"
	"math"
)

// TransactionsMerkleRoot returns the merkle root for the transactions in a block.
// It is the root of two separate merkle trees - The UID tree and WID tree.
//
//	              root = h(uid_root + wid_root)
//		        /                           \
//		  uid_root                        wid_root
//
// A UID is the hash of each transaction with the transaction's proof set to nil.
// A WID is the hash of the transactions' proof.
//
// By committing the transaction in two separate pieces it makes it possible to
// build nodes that only download the transaction without the proof and validate
// an aggregate proof later, while still ensuring the full transaction data is
// committed.
func TransactionsMerkleRoot(txs []*transactions.Transaction) types.ID {
	uids := make([]types.ID, len(txs))
	wids := make([]types.ID, len(txs))
	for i, tx := range txs {
		uids[i] = tx.UID().Clone()
		wids[i] = tx.WID().Clone()
	}
	left := BuildMerkleTreeStore(uids)
	right := BuildMerkleTreeStore(wids)

	root := hash.HashMerkleBranches(left[len(left)-1], right[len(right)-1])
	return types.NewID(root)
}

// nextPowerOfTwo returns the next highest power of two from a given number if
// it is not already a power of two.  This is a helper function used during the
// calculation of a merkle tree.
func nextPowerOfTwo(n int) int {
	// Return the number if it's already a power of 2.
	if n&(n-1) == 0 {
		return n
	}

	// Figure out and return the next power of two.
	exponent := uint(math.Log2(float64(n))) + 1
	return 1 << exponent // 2^exponent
}

// BuildMerkleTreeStore creates a merkle tree from a slice of data, stores it
// using a linear array, and returns a slice of the backing array.  A linear array
// was chosen as opposed to an actual tree structure since it uses about half as
// much memory.  The following describes a merkle tree and how it is stored in a
// linear array.
//
// A merkle tree is a tree in which every non-leaf node is the hash of its
// children nodes.  A diagram depicting how this works for illium transactions
// where h(x) is a hash function follows:
//
//	         root = h1234 = h(h12 + h34)
//	        /                           \
//	  h12 = h(h1 + h2)            h34 = h(h3 + h4)
//	   /            \              /            \
//	h1 = h(tx1)  h2 = h(tx2)    h3 = h(tx3)  h4 = h(tx4)
//
// The above stored as a linear array is as follows:
//
//	[h1 h2 h3 h4 h12 h34 root]
//
// As the above shows, the merkle root is always the last element in the array.
//
// The number of inputs is not always a power of two which results in a
// balanced tree structure as above.  In that case, parent nodes with no
// children are also zero and parent nodes with only a single left node
// are calculated by concatenating the left node with itself before hashing.
// Since this function uses nodes that are pointers to the hashes, empty nodes
// will be nil.
func BuildMerkleTreeStore(data []types.ID) [][]byte {
	// Calculate how many entries are required to hold the binary merkle
	// tree as a linear array and create an array of that size.
	nextPoT := nextPowerOfTwo(len(data))
	arraySize := nextPoT*2 - 1
	merkles := make([][]byte, arraySize)

	// Create the base transactions hashes and populate the array with them.
	for i, txid := range data {
		merkles[i] = make([]byte, len(txid))
		copy(merkles[i], txid[:])
	}

	// Start the array offset after the last transactions and adjusted to the
	// next power of two.
	offset := nextPoT
	for i := 0; i < arraySize-1; i += 2 {
		switch {
		// When there is no left child node, the parent is nil too.
		case merkles[i] == nil:
			merkles[offset] = nil

		// When there is no right child, the parent is generated by
		// hashing the concatenation of the left child with itself.
		case merkles[i+1] == nil:
			newHash := hash.HashMerkleBranches(merkles[i], merkles[i])
			merkles[offset] = newHash

		// The normal case sets the parent node to the hash
		// of the concatentation of the left and right children.
		default:
			newHash := hash.HashMerkleBranches(merkles[i], merkles[i+1])
			merkles[offset] = newHash
		}
		offset++
	}

	return merkles
}

// MerkleInclusionProof returns an inclusion proof which proves that the txid
// in the given merkle tree store.
func MerkleInclusionProof(merkleTreeStore [][]byte, txid types.ID) ([][]byte, uint32) {
	nElements := (len(merkleTreeStore) + 1) / 2

	hashes := make([][]byte, 0, len(merkleTreeStore))
	flags := uint32(0)
	start := 0
	txidClone := txid.Clone()
	compare := txidClone[:]
	for {
		for i := start; i < start+nElements; i++ {
			if bytes.Equal(merkleTreeStore[i], compare) {
				if i%2 == 0 {
					x := make([]byte, len(merkleTreeStore[i+1]))
					copy(x, merkleTreeStore[i+1])
					hashes = append(hashes, x)
					flags <<= 1
					flags |= 0x01
					compare = hash.HashMerkleBranches(compare, merkleTreeStore[i+1])
				} else {
					x := make([]byte, len(merkleTreeStore[i-1]))
					copy(x, merkleTreeStore[i-1])
					hashes = append(hashes, x)
					flags <<= 1
					flags |= 0x00
					compare = hash.HashMerkleBranches(merkleTreeStore[i-1], compare)
				}
			}
		}
		start += nElements
		nElements /= 2
		if start+nElements >= len(merkleTreeStore) {
			break
		}
	}
	return hashes, flags
}
